#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import struct
import sys
import zlib
from pathlib import Path


def process_png(input_file, output_file=None):
    """
    Remove Stable Diffusion prompt information (tEXt parameters chunk) from PNG files
    
    Args:
        input_file (str): Path to the input PNG file
        output_file (str, optional): Path to the output PNG file. If None, overwrite the input file
    
    Returns:
        bool: Whether the processing was successful
    """
    if output_file is None:
        # Create a temporary file if no output file is specified
        output_file = input_file + ".tmp"
        overwrite = True
    else:
        overwrite = False
    
    try:
        with open(input_file, 'rb') as f_in, open(output_file, 'wb') as f_out:
            # Read and write PNG signature
            signature = f_in.read(8)
            if signature != b'\x89PNG\r\n\x1a\n':
                print(f"Error: {input_file} is not a PNG file")
                return False
            
            f_out.write(signature)
            
            # Read and process chunks
            while True:
                # Read chunk length and type
                chunk_data = f_in.read(8)
                if len(chunk_data) < 8:
                    break  # End of file
                
                chunk_length = struct.unpack('>I', chunk_data[:4])[0]
                chunk_type = chunk_data[4:8]
                
                # Read chunk data
                chunk_data = f_in.read(chunk_length)
                chunk_crc = f_in.read(4)
                
                # Skip tEXt parameters chunk
                if chunk_type == b'tEXt' and chunk_data.startswith(b'parameters\0'):
                    print(f"Removed prompt information: {input_file}")
                    continue
                
                # Skip Stable Diffusion custom tEXt parameters chunk
                if chunk_type == b'tEXt' and b'parameters' in chunk_data[:20]:
                    print(f"Removed prompt information: {input_file}")
                    continue
                
                # Skip special AtEXt chunk
                if chunk_type == b'AtEX' and b'parameters' in chunk_data[:20]:
                    print(f"Removed prompt information: {input_file}")
                    continue
                
                # Keep other chunks
                f_out.write(struct.pack('>I', chunk_length))
                f_out.write(chunk_type)
                f_out.write(chunk_data)
                f_out.write(chunk_crc)
                
                # End at IEND chunk
                if chunk_type == b'IEND':
                    break
        
        # If processing was successful, overwrite the original file if needed
        if overwrite:
            os.replace(output_file, input_file)
            print(f"Updated file: {input_file}")
        else:
            print(f"Created new file: {output_file}")
        
        return True
    
    except Exception as e:
        print(f"Error: An error occurred while processing {input_file} - {str(e)}")
        # Remove temporary file if it exists
        if overwrite and os.path.exists(output_file):
            os.remove(output_file)
        return False

def process_directory(directory, output_dir=None, recursive=False):
    """
    Process all PNG files in a directory
    
    Args:
        directory (str): Path to the directory to process
        output_dir (str, optional): Path to the output directory. If None, overwrite input files
        recursive (bool): Whether to recursively process subdirectories
    
    Returns:
        tuple: (number of successful files, number of failed files)
    """
    success_count = 0
    failure_count = 0
    
    path = Path(directory)
    pattern = '**/*.png' if recursive else '*.png'
    
    # Create output directory if specified
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
    
    for png_file in path.glob(pattern):
        # Generate output file path
        if output_dir:
            rel_path = png_file.relative_to(path) if png_file.is_relative_to(path) else png_file.name
            output_file = os.path.join(output_dir, str(rel_path))
            # Create output directory if it doesn't exist
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
        else:
            output_file = None
        
        if process_png(str(png_file), output_file):
            success_count += 1
        else:
            failure_count += 1
    
    return success_count, failure_count

def main():
    """
    Main function
    """
    import argparse
    
    parser = argparse.ArgumentParser(description='Remove prompt information from images generated by Stable Diffusion')
    parser.add_argument('input', help='Path to input file or directory')
    parser.add_argument('-o', '--output', help='Path to output file (when processing a single file) or output directory (when processing a directory)')
    parser.add_argument('-r', '--recursive', action='store_true', help='Process directories recursively')
    
    args = parser.parse_args()
    
    input_path = args.input
    
    if os.path.isfile(input_path):
        # Process single file
        if process_png(input_path, args.output):
            print("Processing complete")
            sys.exit(0)
        else:
            print("Processing failed")
            sys.exit(1)
    
    elif os.path.isdir(input_path):
        # Process directory
        success, failure = process_directory(input_path, args.output, args.recursive)
        print(f"Processing complete: {success} files successful, {failure} files failed")
        
        if failure > 0:
            sys.exit(1)
        sys.exit(0)
    
    else:
        print(f"Error: {input_path} does not exist or is not accessible")
        sys.exit(1)

if __name__ == "__main__":
    main()